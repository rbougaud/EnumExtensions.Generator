using System.Text;

namespace EnumExtensions.Tool.Helpers;

internal static class Template
{
    internal static string Generate(
        string enumName,
        string namespaceName,
        List<string> members)
    {
        var cases = new StringBuilder();
        foreach (var member in members)
        {
            cases.AppendLine($"            {enumName}.{member} => nameof({enumName}.{member}),");
        }

        var hash = Convert.ToHexString(
            System.Security.Cryptography.SHA256.HashData(
                Encoding.UTF8.GetBytes(string.Join('|', members))
            )
        );

        return $@"// <auto-generated/>
// Hash: {hash}
#nullable enable

namespace {namespaceName};

    public static class {enumName}Extensions
    {{
        public static string ToStr(this {enumName} value)
            => value switch
            {{
{cases}                _ => value.ToString(),
            }};

        public static string ToStringLower(this {enumName} value)
            => value switch
            {{
{GenerateLowerCases(enumName, members)}                _ => value.ToString().ToLowerInvariant(),
            }};

        public static string ToStringUpper(this {enumName} value)
            => value switch
            {{
{GenerateUpperCases(enumName, members)}                _ => value.ToString().ToUpperInvariant(),
            }};
        // Parse optimizations
        public static {enumName} Parse(string name)
        {{
            if (TryParse(name, out var result))
                return result;
            
            throw new ArgumentException($""Requested value '{{name}}' was not found."", nameof(name));
        }}

        public static {enumName} Parse(string name, bool ignoreCase)
        {{
            if (TryParse(name, ignoreCase, out var result))
                return result;
            
            throw new ArgumentException($""Requested value '{{name}}' was not found."", nameof(name));
        }}

        public static bool TryParse(string? name, out {enumName} result)
        {{
            return TryParse(name, ignoreCase: false, out result);
        }}

        public static bool TryParse(string? name, bool ignoreCase, out {enumName} result)
        {{
            if (name is null)
            {{
                result = default;
                return false;
            }}

            if (ignoreCase)
            {{
                return name switch
                {{
{GenerateParseSwitchCasesIgnoreCase(enumName, members)}                    _ => (result = default, false).Item2
                }};
            }}
            
            return name switch
            {{
{GenerateParseSwitchCases(enumName, members)}                _ => (result = default, false).Item2
            }};
        }}

        // Validation
        public static bool IsDefined({enumName} value)
            => value switch
            {{
{GenerateIsDefinedCases(enumName, members)}                _ => false,
            }};
        
        // GetNames / GetValues - cached arrays
        private static readonly string[] _names = [{string.Join(", ", members.Select(m => $" \"{m}\""))} ];
        public static string[] GetNames() => _names;

        private static readonly {enumName}[] _values = [{string.Join(", ", members.Select(m => $" {enumName}.{m}"))} ];
        public static {enumName}[] GetValues() => _values;

        public static int GetCount() => {members.Count};
    }}
";
    }

    private static string GenerateLowerCases(string enumName, List<string> members)
    {
        var cases = new StringBuilder();
        foreach (var member in members)
        {
            cases.AppendLine($"            {enumName}.{member} => \"{member.ToLowerInvariant()}\",");
        }
        return cases.ToString();
    }

    private static string GenerateUpperCases(string enumName, List<string> members)
    {
        var cases = new StringBuilder();
        foreach (var member in members)
        {
            cases.AppendLine($"            {enumName}.{member} => \"{member.ToUpperInvariant()}\",");
        }
        return cases.ToString();
    }

    private static string GenerateParseSwitchCases(string enumName, List<string> members)
    {
        var cases = new StringBuilder();
        foreach (var member in members)
        {
            cases.AppendLine($"                \"{member}\" => (result = {enumName}.{member}, true).Item2,");
        }
        return cases.ToString();
    }

    private static string GenerateParseSwitchCasesIgnoreCase(string enumName, List<string> members)
    {
        var cases = new StringBuilder();
        foreach (var member in members)
        {
            cases.AppendLine($"                var s when string.Equals(s, \"{member}\", StringComparison.OrdinalIgnoreCase) => (result = {enumName}.{member}, true).Item2,");
        }
        return cases.ToString();
    }

    private static string GenerateIsDefinedCases(string enumName, List<string> members)
    {
        var cases = new StringBuilder();
        foreach (var member in members)
        {
            cases.AppendLine($"                {enumName}.{member} => true,");
        }
        return cases.ToString();
    }
}